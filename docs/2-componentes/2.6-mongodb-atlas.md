# 2.6 MongoDB Atlas

## ¿Qué es MongoDB Atlas?

**MongoDB Atlas** es la versión en la nube de **MongoDB**, una base de datos **NoSQL orientada a documentos**. Almacena datos en formato JSON (BSON) en lugar de tablas relacionales.

### Características Principales

- **NoSQL**: No requiere esquema fijo
- **Documentos JSON**: Flexible y natural para APIs
- **Escalabilidad horizontal**: Sharding automático
- **Vector Search**: Búsqueda semántica con embeddings
- **Cloud nativo**: Gestionado completamente por MongoDB Inc.

---

## ¿Por qué MongoDB para este Proyecto?

```mermaid
graph TB
    A[Usuario] -->|Pregunta| B[LangGraph Agent]
    B -->|Query Embedding| C[OpenAI Embeddings]
    C -->|Vector [1536]| D[(MongoDB Atlas)]

    subgraph "MongoDB Atlas"
        D -->|Vector Search| E[Colección: Pages]
        E -->|Top 5 páginas| F[Resultados]
    end

    F --> B
    B -->|Respuesta| A

    style D fill:#FFD93D
    style E fill:#4ECDC4
```

**Razones clave**:

1. **Vector Search nativo**: Búsqueda semántica sin necesidad de Pinecone, Weaviate, etc.
2. **Flexibilidad**: Documentos académicos tienen estructura variable
3. **Performance**: Índices vectoriales optimizados
4. **Escalabilidad**: Maneja millones de páginas fácilmente
5. **Atlas Search**: Full-text search + Vector search en uno

---

## Estructura de Datos

### Colección: `Documents`

Metadatos de documentos PDF:

```json
{
  "_id": ObjectId("507f1f77bcf86cd799439011"),
  "nombre": "Reglamento de Pagos 2024",
  "tipo": "Ingeniería Informática",
  "descripcion": "Reglamento de pagos, matrículas y pensiones para estudiantes de Ingeniería Informática."
}
```

**Campos**:
- `nombre`: Nombre del documento
- `tipo`: Escuela o "Información General"
- `descripcion`: Resumen del contenido (usado por IA para seleccionar documento)

### Colección: `Pages` (ScienceBot)

Páginas individuales con embeddings:

```json
{
  "_id": ObjectId("507f1f77bcf86cd799439012"),
  "nombre_archivo": "Reglamento de Pagos 2024",
  "pagina": 3,
  "text": "Artículo 15: El costo de matrícula para pregrado es de S/ 350 soles...",
  "embedding": [0.123, -0.456, 0.789, ... ] // 1536 dimensiones
}
```

**Campos**:
- `nombre_archivo`: Referencia al documento
- `pagina`: Número de página
- `text`: Contenido de texto de la página
- `embedding`: Vector de 1536 dimensiones (OpenAI text-embedding-3-small)

---

## Vector Search: ¿Cómo Funciona?

### 1. **Embeddings** (Vectorización)

Convierte texto a vector numérico:

```python
# Query del usuario
query = "¿Cuánto cuesta la matrícula?"

# OpenAI convierte a vector
embedding = await openai_embeddings.aembed_query(query)
# [0.234, -0.567, 0.123, ..., 0.891]  # 1536 números
```

### 2. **Comparación de Similitud**

MongoDB compara el vector de la query con todos los vectores almacenados usando **similitud de coseno**:

```python
# Similitud entre dos vectores
similarity = cosine_similarity(query_vector, document_vector)
# Valores: 0 (opuesto) a 1 (idéntico)
```

### 3. **Resultados Ordenados**

MongoDB retorna los documentos más similares ordenados por score:

```json
[
  {
    "text": "El costo de matrícula es S/ 350",
    "score": 0.92,  // 92% similar
    "pagina": 3
  },
  {
    "text": "Para matrícula debe pagar...",
    "score": 0.87,  // 87% similar
    "pagina": 5
  }
]
```

---

## Pipeline de Vector Search

```python
# app/core/mongo_db.py

async def search_best_matches(
    self,
    query: str,
    document_name: str | None = None,
    limit: int = 10,
) -> SearchPagesResult:
    """Busca páginas relevantes usando Vector Search."""

    # 1. Convertir query a embedding
    query_embedding = await self.query_to_embedding(query)

    # 2. Pipeline de agregación de MongoDB
    pipeline = [
        {
            "$vectorSearch": {
                "index": "default",                 # Índice vectorial
                "queryVector": query_embedding,     # Vector de la query
                "path": "embedding",                # Campo con embeddings
                "numCandidates": limit * 10,        # Candidatos preliminares
                "limit": limit,                     # Top N resultados
                "filter": {"nombre_archivo": document_name}  # Filtro opcional
            }
        },
        {
            "$project": {
                "_id": 1,
                "nombre_archivo": 1,
                "pagina": 1,
                "text": 1,
                "score": {"$meta": "vectorSearchScore"}  # Score de similitud
            }
        }
    ]

    # 3. Ejecutar
    cursor = collection.aggregate(pipeline)

    # 4. Parsear resultados
    results = []
    async for doc in cursor:
        results.append(
            PageMatch(
                id=str(doc["_id"]),
                file_name=doc.get("nombre_archivo", ""),
                page=doc.get("pagina", 0),
                text=doc.get("text", ""),
                score=doc.get("score", 0.0)
            )
        )

    return SearchPagesResult(matches=results)
```

---

## Índice Vectorial en MongoDB Atlas

Para que Vector Search funcione, se crea un **índice vectorial**:

```json
{
  "type": "vectorSearch",
  "fields": [
    {
      "path": "embedding",
      "numDimensions": 1536,
      "similarity": "cosine",
      "type": "vector"
    }
  ]
}
```

**Configuración**:
- `path`: Campo con el vector (embedding)
- `numDimensions`: 1536 (OpenAI text-embedding-3-small)
- `similarity`: `cosine` (similitud de coseno)

---

## MongoDB vs PostgreSQL vs Redis

| Característica | MongoDB | PostgreSQL | Redis |
|----------------|---------|-----------|-------|
| **Tipo** | NoSQL (documentos) | SQL (relacional) | Key-Value (cache) |
| **Estructura** | JSON flexible | Tablas fijas | Key→Value |
| **Vector Search** | ✅ Nativo | ⚠️ Con extensión | ❌ |
| **Escalabilidad** | Horizontal (sharding) | Vertical | Horizontal |
| **Uso en proyecto** | Documentos académicos | Evolution API | Cache Evolution |
| **Persistencia** | Garantizada | Garantizada | Opcional |

---

## Ventajas de MongoDB Atlas

### 1. **Vector Search Integrado**

No necesitas servicios externos como Pinecone o Weaviate:

```python
# Todo en uno
results = await mongo.search_best_matches(query="matrícula", limit=5)
```

### 2. **Flexibilidad de Esquema**

Cada documento puede tener campos diferentes:

```json
// Documento 1
{
  "nombre": "Reglamento",
  "paginas": 50
}

// Documento 2
{
  "nombre": "Guía",
  "autor": "Universidad",
  "año": 2024
}
```

### 3. **Escalabilidad**

MongoDB Atlas escala automáticamente:
- Más RAM/CPU cuando hay carga
- Sharding para bases de datos grandes
- Réplicas para alta disponibilidad

### 4. **Atlas Search**

Combina full-text search con Vector Search:

```python
# Búsqueda híbrida (texto + vectores)
pipeline = [
    {
        "$search": {
            "compound": {
                "should": [
                    {"text": {"query": "matrícula", "path": "text"}},  # Full-text
                    {"vectorSearch": {"query": embedding, "path": "embedding"}}  # Vector
                ]
            }
        }
    }
]
```

---

## Configuración en el Proyecto

```python
# app/core/config.py

class Settings(BaseSettings):
    # MongoDB Atlas Configuration
    MONGO_URL: str = Field(default="mongodb://localhost:27017")
    MONGO_DATABASE: str = Field(default="ScienceBot")
    MONGO_DOCUMENTS_COLLECTION: str = Field(default="Documents")
    MONGO_PAGES_COLLECTION: str = Field(default="ScienceBot")
```

```python
# app/core/mongo_db.py

class MongoDBService:
    def __init__(self):
        self.mongo_client = AsyncIOMotorClient(settings.MONGO_URL)
        self.db = None

    async def connect_db(self):
        """Conecta a MongoDB Atlas."""
        await self.mongo_client.admin.command("ping")
        self.db = self.mongo_client[settings.MONGO_DATABASE]
        return self.db
```

---

## Performance

### Query Time

```
Vector Search en MongoDB Atlas:
- Query simple: ~50-100ms
- Query con filtros: ~100-200ms
- Batch queries: ~500ms (10 queries)

Comparación:
- PostgreSQL con pgvector: ~200-500ms
- Pinecone: ~50-100ms
- Búsqueda tradicional (LIKE): ~1-5s
```

### Optimizaciones

1. **Índices vectoriales**: `numCandidates` determina precision vs speed
2. **Filtros**: Aplicar antes del Vector Search
3. **Proyección**: Solo retornar campos necesarios
4. **Batch processing**: Procesar múltiples queries juntas

---

## Limitaciones

1. **Costo**: Atlas cobra por recursos usados (RAM, storage, transfer)
2. **Complejidad**: Curva de aprendizaje más alta que SQL
3. **Consistencia**: Eventual consistency en réplicas
4. **Joins**: No hay JOINs nativos (usa $lookup, más lento)

---

## Recursos Adicionales

- [MongoDB Atlas Docs](https://www.mongodb.com/docs/atlas/)
- [Vector Search Guide](https://www.mongodb.com/docs/atlas/atlas-vector-search/vector-search-overview/)
- [Motor (Async Driver)](https://motor.readthedocs.io/)

---

## Próximos Pasos

- **[2.7 Railway](./2.7-railway.md)**: Plataforma de deployment
- **[6.3 Búsqueda Semántica](../6-base-de-datos/6.3-busqueda-semantica.md)**: Pipeline detallado

**Volver al índice**: [README](../README.md)
