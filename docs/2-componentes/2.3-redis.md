# 2.3 Redis

## ¿Qué es Redis?

**Redis** (Remote Dictionary Server) es una **base de datos en memoria** ultra-rápida que funciona como caché, message broker y almacén de estructuras de datos.

### Características Principales

- **En memoria**: Todos los datos en RAM (latencia submilisegundos)
- **Key-Value Store**: Diccionario gigante de clave → valor
- **Estructuras de datos**: Strings, Hashes, Lists, Sets, Sorted Sets
- **Persistencia opcional**: Puede guardar snapshots a disco
- **Pub/Sub**: Sistema de mensajería en tiempo real

---

## ¿Por qué Evolution API usa Redis?

Evolution API usa Redis como **complemento** a PostgreSQL para:

1. **Cache de sesiones**: Acceso ultra-rápido a sesiones activas
2. **Cola de mensajes**: Mensajes pendientes de envío
3. **Estado temporal**: Estado de conexión en tiempo real
4. **Rate limiting**: Control de límites de envío por segundo
5. **Performance**: Reducir carga en PostgreSQL

```mermaid
graph TB
    A[Evolution API]

    subgraph "Hot Data - Redis"
        B[Sesiones Activas<br/>Cache]
        C[Cola de Mensajes<br/>Queue]
        D[Estado Conexión<br/>Real-time]
        E[Rate Limits<br/>Counters]
    end

    subgraph "Cold Data - PostgreSQL"
        F[Sesiones Persistentes]
        G[Historial Mensajes]
        H[Configuraciones]
    end

    A -->|Read/Write| B
    A -->|Push/Pop| C
    A -->|Update| D
    A -->|Increment| E

    A -->|Backup| F
    A -->|Log| G
    A -->|Read| H

    style A fill:#FF6B6B
    style B fill:#DC382D
    style C fill:#DC382D
    style D fill:#DC382D
    style E fill:#DC382D
    style F fill:#336791
    style G fill:#336791
    style H fill:#336791
```

---

## Redis vs PostgreSQL: ¿Cuándo usar cada uno?

| Característica | Redis | PostgreSQL |
|----------------|-------|------------|
| **Velocidad** | ~1ms | ~10-50ms |
| **Persistencia** | Opcional (puede perder datos) | Garantizada |
| **Capacidad** | RAM limitada (GB) | Disco ilimitado (TB) |
| **Estructuras** | Key-Value, Lists, Sets | Tablas relacionales |
| **Uso típico** | Cache, colas, contadores | Datos permanentes |
| **Mejor para** | Datos temporales y frecuentes | Datos críticos |

### Ejemplo de Decisión

**¿Dónde guardar la sesión de WhatsApp?**

✅ **PostgreSQL** (Source of Truth):
```sql
-- Sesión completa con credenciales (permanente)
INSERT INTO sessions (instance_name, session_data)
VALUES ('sciencebot', '{"credentials": "..."}');
```

✅ **Redis** (Cache para acceso rápido):
```redis
# Cache temporal de sesión activa
SET session:sciencebot:active '{"status": "connected", "qr": null}'
EXPIRE session:sciencebot:active 3600  # 1 hora
```

---

## Casos de Uso de Redis en Evolution API

### 1. **Cache de Sesiones Activas**

Evita consultar PostgreSQL en cada mensaje:

```redis
# Guardar sesión en cache
SET session:sciencebot:data '{"creds": "...", "keys": "..."}'
EXPIRE session:sciencebot:data 7200  # 2 horas

# Leer sesión (ultra-rápido)
GET session:sciencebot:data

# Invalidar cache cuando se actualiza en PostgreSQL
DEL session:sciencebot:data
```

**Flujo de lectura**:
```mermaid
graph LR
    A[Evolution API] -->|1. GET| B[Redis]
    B -->|Cache HIT| C[Return Session]
    B -->|Cache MISS| D[PostgreSQL]
    D -->|Read| E[Store in Redis]
    E --> C

    style B fill:#DC382D
    style D fill:#336791
```

### 2. **Cola de Mensajes (Message Queue)**

Mensajes pendientes de envío:

```redis
# Agregar mensaje a cola
LPUSH queue:messages:sciencebot '{"to": "51999999999", "text": "Hola"}'

# Procesar mensaje (FIFO)
RPOP queue:messages:sciencebot

# Ver tamaño de cola
LLEN queue:messages:sciencebot
```

**Ventaja**: Si Evolution API se cae, los mensajes en cola no se pierden (con persistencia activada).

### 3. **Estado de Conexión en Tiempo Real**

```redis
# Marcar instancia como conectada
SET connection:sciencebot:status "connected"

# Timestamp de última actividad
SET connection:sciencebot:last_seen 1698765432

# Revisar si está activa (TTL)
TTL connection:sciencebot:status
```

### 4. **Rate Limiting**

Prevenir spam y baneos de WhatsApp:

```redis
# Incrementar contador de mensajes enviados
INCR ratelimit:sciencebot:messages:1698765432  # timestamp del segundo actual

# Expirar después de 1 minuto
EXPIRE ratelimit:sciencebot:messages:1698765432 60

# Verificar límite (ej: máximo 20 mensajes/segundo)
GET ratelimit:sciencebot:messages:1698765432
```

**Lógica**:
```python
current_second = int(time.time())
key = f"ratelimit:sciencebot:messages:{current_second}"
count = redis.incr(key)
redis.expire(key, 60)

if count > 20:
    raise RateLimitError("Too many messages per second")
```

### 5. **Pub/Sub para Eventos**

Notificaciones en tiempo real entre servicios:

```redis
# Publicar evento de conexión
PUBLISH evolution:events '{"event": "connection.update", "instance": "sciencebot", "status": "connected"}'

# Suscribirse a eventos
SUBSCRIBE evolution:events
```

---

## Estructuras de Datos en Redis

### 1. **Strings** (Simple Key-Value)

```redis
SET user:51999999999:name "Juan Pérez"
GET user:51999999999:name
```

### 2. **Hashes** (Objetos/Diccionarios)

```redis
# Guardar objeto completo
HSET instance:sciencebot name "sciencebot" status "connected" phone "51999999999"

# Leer campo específico
HGET instance:sciencebot status

# Leer todo el objeto
HGETALL instance:sciencebot
```

### 3. **Lists** (Colas FIFO/LIFO)

```redis
# Queue de mensajes
LPUSH queue:messages:sciencebot "Message 1"
LPUSH queue:messages:sciencebot "Message 2"

# Procesar (FIFO)
RPOP queue:messages:sciencebot  # "Message 1"
```

### 4. **Sets** (Conjuntos únicos)

```redis
# Lista de números bloqueados
SADD blocked:numbers "51999999999" "51888888888"

# Verificar si está bloqueado
SISMEMBER blocked:numbers "51999999999"  # 1 (true)
```

### 5. **Sorted Sets** (Conjuntos ordenados)

```redis
# Leaderboard de mensajes enviados
ZADD stats:messages:sent 150 "sciencebot" 230 "support-bot"

# Top 10
ZRANGE stats:messages:sent 0 9 WITHSCORES
```

---

## Redis en Railway

En el proyecto, Redis está desplegado como un **servicio separado**:

```mermaid
graph LR
    A[Evolution API<br/>Service] -->|Connection| B[Redis<br/>Service]

    subgraph Railway Project
        A
        B
    end

    style A fill:#FF6B6B
    style B fill:#DC382D
```

### Variables de Entorno

```bash
# Evolution API se conecta a Redis usando:
REDIS_URL=redis://default:password@redis.railway.internal:6379
REDIS_ENABLED=true
```

**Formato de REDIS_URL**:
```
redis://[usuario]:[password]@[host]:[puerto]/[db]
```

---

## Persistencia en Redis

Redis es **en memoria**, pero puede persistir datos:

### 1. **RDB (Snapshot)**

Guarda snapshot completo periódicamente:

```redis
# Cada 60 segundos si hubo al menos 1000 cambios
SAVE 60 1000

# Snapshot manual
SAVE
```

### 2. **AOF (Append Only File)**

Log de cada comando ejecutado:

```redis
# Configuración
appendonly yes
appendfsync everysec  # Flush a disco cada segundo
```

**Railway probablemente usa**:
- RDB para backups periódicos
- AOF opcional para mayor durabilidad

---

## Performance de Redis

### Velocidad

```
Operaciones por segundo en Redis:
- GET/SET: ~100,000 ops/sec (single thread)
- INCR: ~100,000 ops/sec
- LPUSH: ~80,000 ops/sec

Operaciones en PostgreSQL:
- SELECT simple: ~10,000 ops/sec
- INSERT: ~5,000 ops/sec
```

Redis es **10-20x más rápido** para operaciones simples.

### Uso de Memoria

```redis
# Ver uso de memoria
INFO memory

# Ejemplo de output:
# used_memory_human: 2.5G
# maxmemory: 4G
```

**Políticas de eviction** (cuando se llena la RAM):

```redis
# Evictar keys menos usadas
maxmemory-policy allkeys-lru

# Evictar keys con TTL
maxmemory-policy volatile-ttl
```

---

## Monitoreo de Redis

### Comandos Útiles

```redis
# Ver estadísticas generales
INFO

# Comandos ejecutados por segundo
INFO stats

# Clientes conectados
CLIENT LIST

# Monitor en tiempo real (debugging)
MONITOR

# Ver todas las keys (¡cuidado en producción!)
KEYS *
```

### Métricas en Railway

Railway Dashboard muestra:
1. **Memoria usada**: % de RAM ocupada
2. **Conexiones**: Clientes conectados
3. **Hit rate**: Eficiencia del cache
4. **Commands/sec**: Throughput

---

## Redis en el Contexto del Proyecto

```mermaid
graph TB
    A[Usuario WhatsApp] -->|Mensaje| B[Evolution API]

    B -->|1. Check session cache| C[Redis]
    C -->|Cache HIT| D[Process Message]
    C -->|Cache MISS| E[(PostgreSQL)]
    E -->|Load session| F[Store in Redis]
    F --> D

    D -->|Queue message| G[Redis Queue]
    G -->|Dequeue| H[Send to WhatsApp]

    B -->|2. Webhook| I[FastAPI]

    style B fill:#FF6B6B
    style C fill:#DC382D
    style E fill:#336791
    style I fill:#4ECDC4
```

---

## Ventajas de Redis en Evolution API

1. **Velocidad**: Acceso ultra-rápido a sesiones activas
2. **Escalabilidad**: Maneja miles de operaciones/segundo
3. **Colas**: Gestión robusta de mensajes pendientes
4. **Rate limiting**: Control de spam fácil y eficiente
5. **Pub/Sub**: Eventos en tiempo real entre servicios

---

## Diferencias con MongoDB (usado en el bot)

| Aspecto | Redis | MongoDB Atlas |
|---------|-------|---------------|
| **Propósito** | Cache temporal | Datos permanentes |
| **Usado por** | Evolution API | FastAPI (ScienceBot) |
| **Velocidad** | Submilisegundos | Milisegundos |
| **Datos** | Sesiones, colas | Documentos académicos |
| **Persistencia** | Opcional | Garantizada |
| **Consultas** | Key-Value simple | Queries complejas |

---

## Best Practices

### 1. **Usar TTL (Time To Live)**

```redis
# Evitar memory leaks con expiración automática
SET session:temp:123 "data" EX 3600  # Expira en 1 hora
```

### 2. **Namespacing con Prefijos**

```redis
# Organizar keys con prefijos
session:sciencebot:data
queue:messages:sciencebot
ratelimit:sciencebot:messages
```

### 3. **Pipelines para Operaciones Múltiples**

```python
# En lugar de múltiples comandos
pipe = redis.pipeline()
pipe.set('key1', 'value1')
pipe.set('key2', 'value2')
pipe.incr('counter')
pipe.execute()  # 1 round-trip en lugar de 3
```

### 4. **Monitoring y Alertas**

```redis
# Detectar problemas de memoria
INFO memory | grep used_memory_human
```

---

## Limitaciones de Redis

1. **RAM limitada**: No puede almacenar TB de datos
2. **Single-threaded**: Un comando a la vez (aunque muy rápido)
3. **Sin relaciones**: No hay JOINs como en SQL
4. **Persistencia**: Puede perder datos recientes si se cae

---

## Recursos Adicionales

- [Redis Official Documentation](https://redis.io/docs/)
- [Redis Data Types](https://redis.io/docs/data-types/)
- [Railway Redis Guide](https://docs.railway.app/databases/redis)
- [Redis Best Practices](https://redis.io/docs/management/optimization/)

---

## Próximos Pasos

- **[2.4 FastAPI](./2.4-fastapi.md)**: Framework web del bot
- **[2.6 MongoDB Atlas](./2.6-mongodb-atlas.md)**: Base de datos del bot (diferente stack)

**Volver al índice**: [README](../README.md)
