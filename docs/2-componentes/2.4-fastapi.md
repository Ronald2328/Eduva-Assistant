# 2.4 FastAPI

## ¬øQu√© es FastAPI?

**FastAPI** es un **framework web moderno** para Python, dise√±ado para construir APIs REST de alto rendimiento con validaci√≥n autom√°tica de datos.

### Caracter√≠sticas Principales

- **R√°pido**: Comparable a NodeJS y Go (basado en Starlette)
- **Type hints**: Validaci√≥n autom√°tica con Pydantic
- **Async nativo**: Soporta `async/await` de Python
- **Documentaci√≥n autom√°tica**: OpenAPI (Swagger) incluido
- **Developer-friendly**: Autocompletado y detecci√≥n de errores

---

## ¬øPor qu√© FastAPI para este Proyecto?

```mermaid
graph TB
    A[Evolution API Webhook] -->|POST /webhook| B[FastAPI Server]
    B -->|Parse & Validate| C[Pydantic Models]
    C -->|Route| D[LangGraph Agent]
    D -->|Response| E[Evolution Service]
    E -->|Send Message| F[Evolution API]

    style B fill:#009688
    style C fill:#4ECDC4
```

### Ventajas en este Contexto

1. **Webhooks**: Recibir eventos de Evolution API
2. **Async**: Procesamiento no bloqueante (importante para IA)
3. **Validation**: Asegurar estructura correcta de webhooks
4. **Type safety**: Menos errores en producci√≥n
5. **Performance**: Manejar m√∫ltiples usuarios concurrentes

---

## Estructura del Proyecto FastAPI

```
app/
‚îú‚îÄ‚îÄ main.py                    # Punto de entrada
‚îú‚îÄ‚îÄ lifespan.py               # Lifecycle management
‚îú‚îÄ‚îÄ router.py                 # Router principal
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ health.py            # Health check endpoint
‚îÇ   ‚îî‚îÄ‚îÄ webhook.py           # Webhook de Evolution API
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îî‚îÄ‚îÄ evolution_service.py # Cliente de Evolution API
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ config.py            # Configuraci√≥n (Settings)
‚îÇ   ‚îî‚îÄ‚îÄ mongo_db.py          # Cliente MongoDB
‚îî‚îÄ‚îÄ science_bot/
    ‚îî‚îÄ‚îÄ agent/
        ‚îî‚îÄ‚îÄ graph.py         # LangGraph Agent
```

---

## main.py - Aplicaci√≥n Principal

```python
# app/main.py

import logfire
from fastapi import FastAPI
from fastapi.responses import HTMLResponse
from scalar_fastapi import get_scalar_api_reference

from app.core.config import Environment, settings
from app.lifespan import lifespan
from app.router import router as api_router

# Crear aplicaci√≥n FastAPI
app = FastAPI(
    lifespan=lifespan,           # ‚≠ê Gesti√≥n de lifecycle
    docs_url=None,                # Deshabilitar /docs por defecto
    redoc_url=None,               # Deshabilitar /redoc
    title=settings.APP_NAME,      # "ScienceBot WhatsApp API"
    version=settings.APP_VERSION, # "1.0.0"
)

# Incluir router principal
app.include_router(router=api_router)

# Documentaci√≥n en desarrollo (Scalar)
if settings.ENVIRONMENT == Environment.DEV:
    @app.get(path="/docs", include_in_schema=False)
    async def scalar_api_reference() -> HTMLResponse:
        return get_scalar_api_reference(
            openapi_url=app.openapi_url,
            title=app.title,
        )

# Observabilidad con Logfire
if settings.LOGFIRE_TOKEN:
    logfire.configure(
        service_name=settings.APP_NAME,
        environment=settings.ENVIRONMENT.value,
        token=settings.LOGFIRE_TOKEN,
    )

    logfire.instrument_fastapi(app)      # Instrumentar FastAPI
    logfire.instrument_httpx()           # Instrumentar HTTP calls
    logfire.instrument_openai()          # Instrumentar OpenAI
```

**Conceptos clave**:
- `lifespan`: Inicializa recursos al arrancar (ej: LangGraph)
- `router`: Organiza endpoints
- `Logfire`: Telemetr√≠a autom√°tica

---

## lifespan.py - Gesti√≥n de Recursos

```python
# app/lifespan.py

from contextlib import asynccontextmanager
from fastapi import FastAPI
from app.science_bot.agent.graph import get_graph

@asynccontextmanager
async def lifespan(app: FastAPI):
    # üü¢ STARTUP: Se ejecuta al iniciar el servidor
    print("[INFO] Initializing LangGraph agent...")
    graph = get_graph()
    app.state.science_bot_graph = graph  # Guardar en app.state
    print("[INFO] Agent ready!")

    yield  # ‚è∏Ô∏è Servidor corriendo aqu√≠

    # üî¥ SHUTDOWN: Se ejecuta al cerrar el servidor
    print("[INFO] Cleaning up resources...")
    # Aqu√≠ podr√≠as cerrar conexiones, etc.
```

**¬øPor qu√© `lifespan`?**

- **Eficiencia**: Compilar el grafo una vez (no en cada request)
- **Compartir recursos**: `app.state` accesible en todas las rutas
- **Cleanup**: Cerrar conexiones al apagar

---

## router.py - Organizaci√≥n de Rutas

```python
# app/router.py

from fastapi import APIRouter
from app.routes.health import router as health_router
from app.routes.webhook import router as webhook_router

router = APIRouter()

router.include_router(router=health_router, tags=["health"])
router.include_router(router=webhook_router, tags=["webhook"])
```

**Endpoints del sistema**:

| M√©todo | Ruta | Descripci√≥n |
|--------|------|-------------|
| GET | `/health` | Health check |
| POST | `/webhook` | Webhook de Evolution API |

---

## routes/health.py - Health Check

```python
# app/routes/health.py

from fastapi import APIRouter
from pydantic import BaseModel

router = APIRouter()

class HealthResponse(BaseModel):
    status: str
    service: str

@router.get("/health")
async def health_check() -> HealthResponse:
    """Endpoint para verificar que el servidor est√° vivo."""
    return HealthResponse(
        status="healthy",
        service="ScienceBot WhatsApp API"
    )
```

**Uso t√≠pico**: Railway/Docker lo llama cada 30s para verificar salud.

---

## routes/webhook.py - Webhook Principal

```python
# app/routes/webhook.py (simplificado)

from fastapi import APIRouter, Request
from app.models.webhook import WebhookPayload
from app.services.evolution_service import evolution_service

router = APIRouter()

@router.post("/webhook")
async def handle_webhook(
    webhook: WebhookPayload,  # ‚≠ê Validaci√≥n autom√°tica con Pydantic
    request: Request
):
    """Recibe webhooks de Evolution API."""

    # 1. Parsear mensaje
    parsed = evolution_service.parse_webhook_message(webhook)

    if not parsed:
        return {"status": "ignored"}

    # 2. Obtener grafo de LangGraph
    graph = request.app.state.science_bot_graph

    # 3. Procesar con el agente
    response = await graph.ainvoke(
        input={"messages": [{"role": "user", "content": parsed.text}]},
        config={"phone_number": parsed.phone_number}
    )

    # 4. Enviar respuesta
    await evolution_service.send_message(
        phone_number=parsed.phone_number,
        message=response["messages"][-1].content,
        instance_name="sciencebot"
    )

    return {"status": "processed"}
```

**Flujo del webhook**:
1. Evolution API env√≠a POST a `/webhook`
2. FastAPI valida con `WebhookPayload` (Pydantic)
3. Se parsea el mensaje
4. LangGraph procesa la consulta
5. Se env√≠a respuesta via Evolution API

---

## Modelos Pydantic para Validaci√≥n

```python
# app/models/webhook.py (simplificado)

from pydantic import BaseModel

class MessageKey(BaseModel):
    remoteJid: str          # "51999999999@s.whatsapp.net"
    fromMe: bool            # false
    id: str                 # "3EB0123456..."

class Message(BaseModel):
    conversation: str | None = None        # Mensaje de texto simple
    extendedTextMessage: dict | None = None # Mensaje con formato

class MessageData(BaseModel):
    key: MessageKey
    message: Message
    pushName: str                          # Nombre del contacto
    messageTimestamp: int                  # Unix timestamp

class WebhookPayload(BaseModel):
    event: str               # "messages.upsert"
    instance: str            # "sciencebot-production"
    data: list[MessageData]  # Array de mensajes

class ParsedMessage(BaseModel):
    phone_number: str        # "51999999999"
    text: str                # Texto del mensaje
    from_me: bool            # false
    message_id: str          # ID de WhatsApp
    push_name: str           # Nombre del usuario
    timestamp: int           # Unix timestamp
```

**Ventajas de Pydantic**:
- Validaci√≥n autom√°tica de tipos
- Conversi√≥n de tipos (str ‚Üí int, etc.)
- Documentaci√≥n autom√°tica en OpenAPI
- Errores claros si la estructura es incorrecta

---

## Configuraci√≥n con Pydantic Settings

```python
# app/core/config.py

from pydantic import Field
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    APP_NAME: str = Field(default="ScienceBot WhatsApp API")
    APP_VERSION: str = Field(default="1.0.0")

    # Evolution API
    EVOLUTION_API_URL: str = Field(default="http://localhost:8080")
    EVOLUTION_API_KEY: str = Field(default="mi_api_key_evolution")

    # OpenAI
    OPENAI_API_KEY: str = Field(default="")
    OPENAI_MODEL: str = Field(default="gpt-4o-mini")

    # MongoDB
    MONGO_URL: str = Field(default="mongodb://localhost:27017")

    model_config = {
        "env_file": ".env",          # Lee variables de .env
        "env_file_encoding": "utf-8",
        "case_sensitive": True,      # OPENAI_API_KEY (may√∫sculas)
        "extra": "ignore",           # Ignorar variables extra
        "frozen": True,              # Inmutable (no se puede modificar)
    }

settings = Settings()  # ‚≠ê Instancia global
```

**Uso**:
```python
from app.core.config import settings

print(settings.OPENAI_API_KEY)  # Lee de .env autom√°ticamente
```

---

## Async/Await en FastAPI

**Todas las operaciones son as√≠ncronas**:

```python
# ‚úÖ Async (no bloquea otros requests)
@router.post("/webhook")
async def handle_webhook(webhook: WebhookPayload):
    response = await openai_call()      # Async
    await mongo_service.save()          # Async
    await evolution_service.send()      # Async
    return response

# ‚ùå Sync (bloquear√≠a el servidor)
@router.post("/webhook")
def handle_webhook(webhook: WebhookPayload):
    response = openai_call()            # Sync (bloquea!)
    return response
```

**Ventaja**: El servidor puede manejar m√∫ltiples usuarios simult√°neamente mientras espera respuestas de OpenAI/MongoDB.

---

## Manejo de Errores

```python
from fastapi import HTTPException

@router.post("/webhook")
async def handle_webhook(webhook: WebhookPayload):
    try:
        # Procesar mensaje
        pass
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        raise HTTPException(status_code=500, detail="Internal error")
```

**FastAPI autom√°ticamente convierte a JSON**:
```json
{
  "detail": "Internal error"
}
```

---

## Dependency Injection

FastAPI permite inyectar dependencias:

```python
from fastapi import Depends

def get_evolution_service():
    return EvolutionAPIService()

@router.post("/webhook")
async def handle_webhook(
    webhook: WebhookPayload,
    service: EvolutionAPIService = Depends(get_evolution_service)
):
    await service.send_message(...)
```

**Ventaja**: F√°cil de testear (mockear dependencias).

---

## Documentaci√≥n Autom√°tica

FastAPI genera **OpenAPI** autom√°ticamente:

```
http://localhost:8000/docs  # Scalar UI
```

**Muestra**:
- Todos los endpoints
- Par√°metros y tipos
- Modelos Pydantic
- Try it out (probar desde el navegador)

---

## FastAPI vs Otros Frameworks

| Framework | Velocidad | Async | Type Safety | Docs |
|-----------|-----------|-------|-------------|------|
| **FastAPI** | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚úÖ | ‚úÖ | ‚úÖ |
| Flask | ‚≠ê‚≠ê‚≠ê | ‚ùå (extensi√≥n) | ‚ùå | ‚ùå |
| Django | ‚≠ê‚≠ê | ‚úÖ (parcial) | ‚ùå | ‚ùå |
| Express.js | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚úÖ | ‚ùå | ‚ùå |

**FastAPI es ideal para**:
- APIs modernas con async
- Integraci√≥n con IA (OpenAI, LangChain)
- Validaci√≥n estricta de datos
- Microservicios

---

## Performance

```
Requests por segundo (benchmark):
- FastAPI: ~60,000 req/s
- Flask: ~20,000 req/s
- Django: ~10,000 req/s
```

**Async permite**:
- Manejar muchos usuarios concurrentes
- No bloquear en llamadas a OpenAI/MongoDB
- Mejor uso de CPU

---

## Testing con FastAPI

```python
from fastapi.testclient import TestClient
from app.main import app

client = TestClient(app)

def test_health():
    response = client.get("/health")
    assert response.status_code == 200
    assert response.json() == {"status": "healthy"}

def test_webhook():
    payload = {
        "event": "messages.upsert",
        "instance": "test",
        "data": [...]
    }
    response = client.post("/webhook", json=payload)
    assert response.status_code == 200
```

---

## Recursos Adicionales

- [FastAPI Official Docs](https://fastapi.tiangolo.com/)
- [Pydantic Documentation](https://docs.pydantic.dev/)
- [FastAPI Tutorial](https://fastapi.tiangolo.com/tutorial/)

---

## Pr√≥ximos Pasos

- **[2.5 LangGraph](./2.5-langgraph.md)**: Motor del agente conversacional
- **[3.1 Recepci√≥n de Mensaje](../3-flujo-de-datos/3.1-recepcion-mensaje.md)**: Flujo completo del webhook

**Volver al √≠ndice**: [README](../README.md)
